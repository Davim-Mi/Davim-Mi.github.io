# Java 泛型  
## 什么是泛型  
泛型是jdk5引入的类型机制，就是将类型参数化。

泛型机制将类型转换时的类型检查从运行时提前到了编译时，使用泛型编写的代码比杂乱的使用object并在需要时再强制类型转换的机制具有更好的可读性和安全性。

泛型程序设计意味着程序可以被不同类型的对象重用，类似c++的模版。

泛型对于集合类尤其有用，如ArrayList。这里可能有疑问，既然泛型为了适应不同的对象，ArrayList本来就可以操作不同类型的对象呀？那是因为没有泛型之前采用继承机制实现的，实际上它只维护了一个Object对象的数组。结果就是对List来说它只操作了一类对象Object，而在用户看来却可以保存不同的对象。

泛型提供了更好的解决办法——类型参数，如：

```
List<String> list = new ArrayList<String>()；
```
优点如下：
1. 可读性，从字面上就可以判断集合中的内容类型
2. 类型检查，避免插入非法类型
3. 获取数据时不再需要强制类型转换  

## 泛型类  
代码
```
public class Pair<T> {
	private T field;
}
```
其中 &lt;T&gt; 是类型参数定义
使用时：Pair&lt;String&gt; p = new Pair&lt;String&gt;(); 此时类内部的field就是字符串类型了。
如果引用多个类型，可以使用逗号分隔：&lt;S, D&gt;。

类型参数名可以使用任意字符串，建议使用有代表意义的单个字符，以便于和普通类型名区分，如：T代表type，有原数据和目的数据就用S，D，子元素类型用E等。当然，你也可以定义为XYZ,甚至xyZ。

## 泛型方法
定义如下：
```
public class GenericMethod { 
	public static <T> T getMiddle(T... a){
		return a[a.length/2]; }
}
```
与泛型类一样，&lt;T&gt; 是类型参数定义。
严格的调用方式：
```
String o = GenericMethod.<String>getMiddle("213","result","12");
```
一般情况下调用时可以省略类型参数&lt;String&gt;，看起来就像定义String类型参数的方法：
```
GenericMethod.getMiddle(String,String,String)，
```
这是因为jdk会根据参数类型进行推断。


看一下下面的例子：

```
Object o= GenericMethod.getMiddle("213",0,"12");
System.out.println(o.getClass());
System.out.println(o);
```

输出结果为：
```
class java.lang.Integer 
0
```
这是因为jdk推断三个参数的共同父类，匹配为Object,那么相当于：
```
Object o = GenericMethod.<Object>getMiddle("213",0,"12");
```








